package sg.edu.nus.comp.cs4218;

import org.junit.jupiter.params.provider.Arguments;
import sg.edu.nus.comp.cs4218.exception.AbstractApplicationException;
import sg.edu.nus.comp.cs4218.exception.ExitException;
import sg.edu.nus.comp.cs4218.exception.ShellException;
import sg.edu.nus.comp.cs4218.impl.cmd.CallCommand;
import sg.edu.nus.comp.cs4218.impl.util.StringUtils;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.attribute.PosixFilePermission;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.mock;

@SuppressWarnings("PMD.AvoidDuplicateLiterals")
public final class CommandTestUtils {

    public static final String SHELL_EXCEPTION = "shell: %s";
    public static final String INVALID_COMMAND = "Invalid command executed.";
    public static final String SHELL_TERMINATED = "Shell has terminated.";

    public static final String SUB_COMMAND_TEST = "subCommandInvoked";
    public static final String VALID_TEST_STRING = "This is valid test string %d";
    public static final String TEST_STR_NEWLINES = "This is valid test string" + System.lineSeparator() +
            "with a new line";

    private CommandTestUtils() {
    }

    /*
     * Create a Stream of Arguments of a valid command strings
     */
    public static Stream<Arguments> validCommandsStrings() {
        return Stream.of(
                Arguments.of("echo A B C"),
                Arguments.of("cd A/New"),
                Arguments.of("wc test.txt"),
                Arguments.of("wc test1.txt text2.txt"),
                Arguments.of("cp foo.txt bar.txt"),
                Arguments.of("cp *.txt foo"),
                Arguments.of("cp -r hello foo"),
                Arguments.of("grep hunting example.txt"),
                Arguments.of("cut -c 1,8 test.txt"),
                Arguments.of("cut -c 1-8 test.txt"),
                Arguments.of("exit"),
                Arguments.of("ls *"),
                Arguments.of("uniq 1.txt"),
                Arguments.of("uniq -c 1.txt"),
                Arguments.of("uniq -d 1.txt"),
                Arguments.of("uniq -D 1.txt"),
                Arguments.of("mv *.txt test"),
                Arguments.of("sort -nr testing.txt test2.txt"),
                Arguments.of("rm 1.txt"),
                Arguments.of("rm -d test"),
                Arguments.of("tee 1.txt"),
                Arguments.of("cat myfile.txt"),
                Arguments.of("cat *.txt"),
                Arguments.of("cat -n myfile.txt"),
                Arguments.of("cat -n myfile.txt myfile2.txt"),
                Arguments.of("ls articles/*"),
                Arguments.of("ls x*"),
                Arguments.of("ls code/article*"),
                Arguments.of("echo hello world"),
                Arguments.of("echo ls *")
        );
    }

    /*
     * Create a Stream of Arguments of a valid command strings with IO, the input file and the output file.
     */
    public static Stream<Arguments> validCommandsStringsWithIO() {
        return Stream.of(
                Arguments.of("echo hi > testing.txt", null, "testing.txt"),
                Arguments.of("echo hi < output2 < output2", "output2", null),
                Arguments.of("wc -c -l < test.txt", "test.txt", null),
                Arguments.of("cat File1.txt File2.txt > union.txt", null, "union.txt"),
                Arguments.of("tee -a 1.txt < 2.txt", "2.txt", null),
                Arguments.of("paste A.txt B.txt > AB.txt", null, "AB.txt"),
                Arguments.of("paste -s A.txt B.txt > CD.txt", null, "CD.txt"),
                Arguments.of("paste – A.txt - < E.txt > FG.txt", "E.txt", "FG.txt"),
                Arguments.of("paste < file.txt", "file.txt", null),
                Arguments.of("grep InterestingString < text1.txt > result.txt", "text1.txt", "result.txt")
        );
    }

    /*
     * Create a Stream of Arguments of a valid command and args (with invalidIO), can be joined together to be
     * a valid command. However, these commands cannot be generated by our application since CommandBuilder will
     * tokenize these commands differently. Currently it will be used by spliting the spaces.
     */
    public static Stream<Arguments> validCommandsWithInvalidIO() {
        return Stream.of(
                Arguments.of("echo", "hi >> testing.txt"),
                Arguments.of("wc", "-c -l << test.txt"),
                Arguments.of("wc", "-c -l >< test.txt"),
                Arguments.of("cat", "File1.txt File2.txt <> union.txt"),
                Arguments.of("paste", "– A.txt - << E.txt >> FG.txt"),
                Arguments.of("grep", "InterestingString << text1.txt >> result.txt"),
                Arguments.of("echo", "hi >? testing.txt")
        );
    }

    /*
     * Create a Stream of Arguments of a valid command and args (with invalidIO), can be joined together to be a valid
     * command
     */
    public static Stream<Arguments> invalidCommandsWithvalidIO() {
        return Stream.of(
                Arguments.of("echo hi < DoesNotExist"),
                Arguments.of("echo hi < "),
                Arguments.of("echo hi > "),
                Arguments.of("echo hi > <"),
                Arguments.of("echo hi > createThis < ")
        );
    }

    /*
     * Create a Stream of Arguments of a valid pipe command strings and the expected call commands after
     * evaluating the pipe.
     */
    public static Stream<Arguments> validPipeCommandsStrings() {
        return Stream.of(
                Arguments.of("echo hello | tee 1.txt",
                        List.of(List.of("echo", "hello"), List.of("tee", "1.txt"))),
                Arguments.of("ls | echo hello world",
                        List.of(List.of("ls"), List.of("echo", "hello", "world"))),
                Arguments.of("echo \"baz\" | cut -b 2",
                        List.of(List.of("echo", "\"baz\""), List.of("cut", "-b", "2"))),
                Arguments.of("paste articles/text1.txt | grep \"Interesting String\"",
                        List.of(List.of("paste", "articles/text1.txt"), List.of("grep", "\"Interesting String\""))),
                Arguments.of("cat articles | paste - text1.txt | echo | cat File1.txt | grep \"Interesting String\"",
                        List.of(List.of("cat", "articles"), List.of("paste", "-", "text1.txt"), List.of("echo"),
                                List.of("cat", "File1.txt"), List.of("grep", "\"Interesting String\""))),
                Arguments.of("rm cs4218_test | echo testing | tee | cat - > cs4218_test | cat - | grep \"Interesting String\" < cs4218 | wc",
                        List.of(List.of("rm", "cs4218_test"), List.of("echo", "testing"), List.of("tee"),
                                List.of("cat", "-", ">", "cs4218_test"), List.of("cat", "-"),
                                List.of("grep", "\"Interesting String\"", "<", "cs4218"), List.of("wc")))
        );
    }

    /*
     * Create a Stream of Arguments of a valid sequence command strings and the expected call commands after
     * evaluating the semicolon.
     */
    public static Stream<Arguments> validSequenceCommandsStrings() {
        return Stream.of(
                Arguments.of("cd articles; paste text1.txt",
                        List.of(List.of("cd", "articles"), List.of("paste", "text1.txt"))),
                Arguments.of("echo \"test 123\"; cat File1.txt File2.txt > union.txt; grep \"Interesting String\" < text1.txt > result.txt",
                        List.of(List.of("echo", "\"test 123\""), List.of("cat", "File1.txt", "File2.txt", ">", "union.txt"),
                                List.of("grep", "\"Interesting String\"", "<", "text1.txt", ">", "result.txt"))),
                Arguments.of("cd articles; echo `paste text1.txt`",
                        List.of(List.of("cd", "articles"), List.of("echo", "`paste text1.txt`"))),
                Arguments.of("cd articles; paste text1.txt | grep \"Interesting String\"",
                        List.of(List.of("cd", "articles"), List.of("paste", "text1.txt"), List.of("grep", "\"Interesting String\""))),
                Arguments.of("echo \"test 123\"; paste text1.txt | cat - File2.txt > union.txt; grep -H \"Interesting String\" < text1.txt > result.txt",
                        List.of(List.of("echo", "\"test 123\""), List.of("paste", "text1.txt"), List.of("cat", "-", "File2.txt", ">", "union.txt"),
                                List.of("grep", "-H", "\"Interesting String\"", "<", "text1.txt", ">", "result.txt"))),
                Arguments.of("cat 'articles' | paste - text1.txt; cat File1.txt | grep \"Interesting String\"",
                        List.of(List.of("cat", "'articles'"), List.of("paste", "-", "text1.txt"),
                                List.of("cat", "File1.txt"), List.of("grep", "\"Interesting String\""))),
                Arguments.of("cat articles | paste - text1.txt; cd newDir; cat File1.txt | grep \"Interesting String\"",
                        List.of(List.of("cat", "articles"), List.of("paste", "-", "text1.txt"), List.of("cd", "newDir"),
                                List.of("cat", "File1.txt"), List.of("grep", "\"Interesting String\""))),
                Arguments.of("cat articles; paste - text1.txt; cd newDir; cat File1.txt; grep \"Interesting String\"",
                        List.of(List.of("cat", "articles"), List.of("paste", "-", "text1.txt"), List.of("cd", "newDir"),
                                List.of("cat", "File1.txt"), List.of("grep", "\"Interesting String\"")))
        );
    }

    /*
     * Create a Stream of Arguments of a List of expected Commands with Quotes after evaluation.
     * Can be joined together to return a valid command string.
     */
    public static Stream<Arguments> validCommandsWithQuotesStrings() {
        return Stream.of(
                Arguments.of(List.of("echo", "noQuotes"), "noQuotes"),
                Arguments.of(List.of("echo", "\"A*B*C\""), "A*B*C"),
                Arguments.of(List.of("grep", "\"Interesting String\"", "<", "text1.txt", ">", "result.txt"), "Interesting String"),
                Arguments.of(List.of("grep", "\"hunting the shark\"", "example.txt"), "hunting the shark"),
                Arguments.of(List.of("grep", "\"CS4218 module\"", "A.txt"), "CS4218 module"),
                Arguments.of(List.of("echo", "\"hello world\""), "hello world"),
                Arguments.of(List.of("echo", "'Travel time Singapore -> Paris is 13h and 15`'"), "Travel time Singapore -> Paris is 13h and 15`"),
                Arguments.of(List.of("paste", "`ls x*`", ">", "all.txt"), SUB_COMMAND_TEST),
                Arguments.of(List.of("echo", "\"This is space:`echo \" \"`.\""), "This is space:" + SUB_COMMAND_TEST + "."),
                Arguments.of(List.of("echo", "'This is space:`echo \" \"`.'"), "This is space:`echo \" \"`."),
                Arguments.of(List.of("echo", "\"This is space:' '.\""), "This is space:' '."),
                Arguments.of(List.of("echo", "\"'This is space `echo \" \"`'\""), "'This is space " + SUB_COMMAND_TEST + "'"),
                Arguments.of(List.of("echo", "'\"This is space `echo \" \"`\"'"), "\"This is space `echo \" \"`\""),
                Arguments.of(List.of("echo", "`echo \"‘quote is not interpreted as special character’\"`"), SUB_COMMAND_TEST),
                Arguments.of(List.of("echo", "test*"), "test*")
        );
    }

    /*
     * Create a Stream of Arguments of a List of expected Commands with Asterisk after evaluation.
     * Can be joined together to return a valid command string.
     */
    public static Stream<Arguments> validCommandsWithAsterisks() {
        return Stream.of(
                Arguments.of(List.of("echo", "ls *"), "ls"),
                Arguments.of(List.of("echo", "ls **"), "ls"),
                Arguments.of(List.of("echo", "ls * *"), "ls"),
                Arguments.of(List.of("echo", "* ls *"), "ls")
        );
    }

    public static List<Command> generateValidCommandsWithExit(InputStream inputStream) throws FileNotFoundException, AbstractApplicationException, ShellException {
        List<Command> mockCommands = new ArrayList<>();

        Command mockValidCommand1 = mock(Command.class);
        doAnswer(args -> {
            OutputStream output = args.getArgument(1);
            output.write(String.format(VALID_TEST_STRING, 0).getBytes());
            output.flush();
            return null;
        }).when(mockValidCommand1).evaluate(eq(inputStream), any());

        Command mcokExitCommand = mock(Command.class);
        doThrow(new ExitException(SHELL_TERMINATED)).when(mcokExitCommand).evaluate(eq(inputStream), any());

        Command mockValidCommand2 = mock(Command.class);
        doAnswer(args -> {
            OutputStream output = args.getArgument(1);
            output.write(String.format(VALID_TEST_STRING, 1).getBytes());
            output.flush();
            return null;
        }).when(mockValidCommand2).evaluate(eq(inputStream), any());


        mockCommands.add(mockValidCommand1);
        mockCommands.add(mcokExitCommand);
        mockCommands.add(mockValidCommand2);

        return mockCommands;
    }

    /*
     * Generate invalid commands in between valid commands
     */
    public static List<Command> generateValidAndInvalidCommands() throws FileNotFoundException, AbstractApplicationException, ShellException {
        return generateValidAndInvalidCallCommands(new ShellException(INVALID_COMMAND)).stream().map(x -> (Command) x).collect(Collectors.toList());
    }

    /*
     * Generate invalid call commands in between valid call commands
     */
    public static List<CallCommand> generateValidAndInvalidCallCommands(Throwable exception) throws FileNotFoundException, AbstractApplicationException, ShellException {
        List<CallCommand> mockCommands = new ArrayList<>();

        CallCommand mockValidCommand1 = mock(CallCommand.class);
        doAnswer(args -> {
            OutputStream output = args.getArgument(1);
            output.write(String.format(VALID_TEST_STRING, 0).getBytes());
            output.flush();
            return null;
        }).when(mockValidCommand1).evaluate(any(), any());

        CallCommand mInvalCom = mock(CallCommand.class);
        doThrow(exception).when(mInvalCom).evaluate(any(), any());

        CallCommand mockValidCommand2 = mock(CallCommand.class);
        doAnswer(args -> {
            OutputStream output = args.getArgument(1);
            output.write(String.format(VALID_TEST_STRING, 1).getBytes());
            output.flush();
            return null;
        }).when(mockValidCommand2).evaluate(any(), any());


        mockCommands.add(mockValidCommand1);
        mockCommands.add(mInvalCom);
        mockCommands.add(mockValidCommand2);

        return mockCommands;
    }

    /*
     * Generate invalid commands
     */
    public static List<Command> generateInvalidCommands(InputStream inputStream) throws FileNotFoundException, AbstractApplicationException, ShellException {
        List<Command> mockCommands = new ArrayList<>();

        Command mInvalCom1 = mock(Command.class);
        doThrow(new ShellException(INVALID_COMMAND)).when(mInvalCom1).evaluate(eq(inputStream), any());

        Command mInvalCom2 = mock(Command.class);
        doThrow(new ShellException(INVALID_COMMAND)).when(mInvalCom2).evaluate(eq(inputStream), any());

        Command mInvalCom3 = mock(Command.class);
        doThrow(new ShellException(INVALID_COMMAND)).when(mInvalCom3).evaluate(eq(inputStream), any());


        mockCommands.add(mInvalCom1);
        mockCommands.add(mInvalCom2);
        mockCommands.add(mInvalCom3);

        return mockCommands;
    }

    /*
     * Generate a sequence of commands, e.g. echo 123; echo 456; echo 789; echo 012
     */
    public static List<Command> generateCommands(int numOfCommands, InputStream inputStream) throws FileNotFoundException, AbstractApplicationException, ShellException {
        List<Command> mockCommands = new ArrayList<>();
        for (int i = 0; i < numOfCommands; i++) {
            Command mockCommand = mock(Command.class);
            int finalI = i;
            doAnswer(args -> {
                OutputStream output = args.getArgument(1);
                output.write(String.format(VALID_TEST_STRING, finalI).getBytes());
                return null;
            }).when(mockCommand).evaluate(eq(inputStream), any());
            mockCommands.add(mockCommand);
        }
        return mockCommands;
    }

    /*
     * Generate a pipe of call commands, e.g. echo 123 | echo 456 | echo
     */
    public static List<CallCommand> generateCallCommands(int numOfCommands) throws FileNotFoundException, AbstractApplicationException, ShellException {
        List<CallCommand> mockCommands = new ArrayList<>();
        for (int i = 0; i < numOfCommands; i++) {
            CallCommand mockCommand = mock(CallCommand.class);
            int finalI = i;
            doAnswer(args -> {
                InputStream input = args.getArgument(0);
                OutputStream output = args.getArgument(1);
                output.write(input.readAllBytes());
                return null;
            }).when(mockCommand).evaluate(any(), any());
            mockCommands.add(mockCommand);
        }
        return mockCommands;
    }

    public static void generateTestFiles(Path tempDir, List<String> fileNames) throws IOException {
        if (!Files.isDirectory(tempDir)) {
            Files.createDirectories(tempDir);
        }
        for (String fileName : fileNames) {
            Path file = tempDir.resolve(fileName);
            Files.createFile(file);
        }
    }

    public static Path generateFileWithPermission(boolean canRead, Path tempDir) throws IOException {
        if (!Files.isDirectory(tempDir)) {
            Files.createDirectories(tempDir);
        }
        String fileName = "fileNoReadPerm.txt";
        if (canRead) {
            fileName = "fileNoWritePerm.txt";
        }
        Path filePath = tempDir.resolve(fileName);
        Files.createFile(filePath);

        if (canRead) {
            Files.setPosixFilePermissions(filePath, new HashSet<>(Collections.singletonList(PosixFilePermission.OWNER_READ)));
        } else {
            Files.setPosixFilePermissions(filePath, new HashSet<>(Collections.singletonList(PosixFilePermission.OWNER_WRITE)));
        }

        return filePath;
    }

    public static Path generateFolderWithPermission(boolean canRead, Path tempDir) throws IOException {
        if (!Files.isDirectory(tempDir)) {
            Files.createDirectories(tempDir);
        }
        String folderName = "folderNoReadPerm";
        if (canRead) {
            folderName = "folderNoWritePerm";
        }
        Path folderPath = tempDir.resolve(folderName);
        Files.createDirectories(folderPath);

        if (canRead) {
            Files.setPosixFilePermissions(folderPath, new HashSet<>(Collections.singletonList(PosixFilePermission.OWNER_READ)));
        } else {
            Files.setPosixFilePermissions(folderPath, new HashSet<>(Collections.singletonList(PosixFilePermission.OWNER_WRITE)));
        }

        return folderPath;
    }

    public static List<Path> populateTestFiles(List<String> fileNames, List<String> inputs, Path tempDir) throws IOException {
        if (!Files.isDirectory(tempDir)) {
            Files.createDirectories(tempDir);
        }
        List<Path> filePaths = new ArrayList<>();
        int index = 0;
        for (String fileName : fileNames) {
            Path file = tempDir.resolve(fileName);
            Files.deleteIfExists(file);
            Files.createFile(file);

            Files.write(file, Collections.singleton(inputs.get(index)));
            index++;
            filePaths.add(file);
        }

        return filePaths;
    }

    public static List<Path> populateTestFolders(List<String> folderNames, Path tempDir) throws IOException {
        if (!Files.isDirectory(tempDir)) {
            Files.createDirectories(tempDir);
        }
        List<Path> folderPaths = new ArrayList<>();
        int index = 0;
        for (String fileName : folderNames) {
            Path file = tempDir.resolve(fileName);
            Files.deleteIfExists(file);
            Files.createDirectories(file);
            index++;
            folderPaths.add(file);
        }

        return folderPaths;
    }

    public static String concatenateLinesWithSeparator(String... inputs) {
        String output = "";
        for (String input : inputs) {
            output += input + System.lineSeparator();
        }
        return output.stripTrailing();
    }

    public static String concatenateLinesWithTab(String... inputs) {
        String output = "";
        for (String input : inputs) {
            output += StringUtils.CHAR_TAB + input;
        }
        return output;
    }

    public static List<Path> createFiles(Path tempDir, String input, String output) throws IOException {
        List<Path> paths = new ArrayList<>();
        if (input != null) {
            Path fullPathname = tempDir.resolve(input);
            paths.add(Files.createFile(fullPathname));
        } else {
            paths.add(null);
        }
        if (output != null) {
            Path fullPathname = tempDir.resolve(output);
            paths.add(Files.createFile(fullPathname));
        } else {
            paths.add(null);
        }
        return paths;
    }
}
